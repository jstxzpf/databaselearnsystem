# 第一范式和第二范式的讲解

在设计关系型数据库时，规范化是一个至关重要的过程，它能帮助我们减少数据冗余并提高系统的效率与一致性。规范化的目标是通过消除重复的数据元素来确保每个属性都是不可分割的，并且每张表都只描述一个实体或事务的信息。以下我们将详细讨论第一范式和第二范式的定义、原理及其在数据库系统中的作用。

## 第一范式 (1NF)

### 定义
**第一范式**是规范化过程的第一个阶段，它的核心思想是确保每个属性都是原子性的，也就是说每个数据项都应该是不可分割的基本单位。例如，在一个包含员工信息的表中，不应该将多个值组合在一个字段内（如用逗号分隔的名字和姓氏），而是应该拆分为两个独立的列。

### 原理
- 数据库中的每张表都必须满足基本的数据类型要求。
- 表中的每个属性都有一个唯一的名称，并且每个单元格只包含单一值，没有重复字段。

### 在数据库系统中的作用
- 有助于减少数据冗余和更新异常。
- 确保数据库中的每一项信息都是独立的、不可再分的最小单位。

### 实际应用场景与示例

假设我们有一个简单的数据库表`employees`来存储员工的详细信息，未规范化前的状态可能如下所示：

```sql
CREATE TABLE employees (
    employeeId INT,
    fullName VARCHAR(100),
    salary DECIMAL(9, 2)
);
```

在第一范式下，我们会将`fullName`拆分为两个字段（name和surname）来确保每个属性是原子性的。

规范化后的表定义如下：

```sql
CREATE TABLE employees (
    employeeId INT,
    name VARCHAR(50),
    surname VARCHAR(50),
    salary DECIMAL(9, 2)
);
```

### Mermaid图表表示

第一范式强调的是**数据项的原子性**，可以通过以下简单的流程图来表示：

```mermaid
graph TD
    A[开始] --> B{每个属性是否为单一值?}
    B -- 是 --> C[继续规范化]
    B -- 否 --> D[拆分非基本单位]
    D --> C
```

## 第二范式 (2NF)

### 定义和原理

**第二范式**是在满足第一范式的基础上，进一步要求消除表中的部分函数依赖。具体来说，如果一张表中存在一个唯一的主键，并且表中的所有非关键字属性完全依赖于整个主键而不是其一部分时，则该表符合2NF。

- **部分函数依赖（partial functional dependency）**: 如果存在A->B形式的函数依赖关系，并且A不是候选键的一部分但却是某个候选键的一个子集，那么就称这种依赖为部分函数依赖。
  
### 在数据库系统中的作用

通过消除部分函数依赖可以减少数据冗余和更新异常。

### 实际应用场景与示例
假设我们有一个`orders_details`表用于存储订单信息：

```sql
CREATE TABLE orders_details (
    orderId INT,
    customerId INT,
    orderDate DATE,
    productCode CHAR(10),
    quantity INT
);
```

这里，`(orderId, customerId)`共同作为主键。但是，如果我们在其他列中只依赖于`orderId`（例如，在另一个表`orders`中有类似的字段），那么这种部分函数依赖是不理想的。

为满足2NF，我们需要将该表拆分为两个：

```sql
CREATE TABLE orders (
    orderId INT PRIMARY KEY,
    customerId INT,
    orderDate DATE
);

CREATE TABLE order_details (
    orderId INT,
    productCode CHAR(10),
    quantity INT,
    FOREIGN KEY (orderId) REFERENCES orders(orderId)
);
```

### Mermaid图表表示

第二范式强调的是**消除部分函数依赖**，流程图如下所示：

```mermaid
graph TD
    A[开始] --> B{是否存在非主键属性只依赖于部分候选键?}
    B -- 否 --> C[符合2NF]
    B -- 是 --> D[拆分表]
    D --> C
```

通过这两个阶段的规范化，我们可以设计出更高效、更新一致且易于维护的关系型数据库结构。